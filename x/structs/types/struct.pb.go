// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: structs/structs/struct.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Struct struct {
	// What it is
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Index uint64 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Type  uint64 `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	// Who is it
	Creator string `protobuf:"bytes,4,opt,name=creator,proto3" json:"creator,omitempty"`
	Owner   string `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	// Where it is
	LocationType   ObjectType `protobuf:"varint,6,opt,name=locationType,proto3,enum=structs.structs.ObjectType" json:"locationType,omitempty"`
	LocationId     string     `protobuf:"bytes,7,opt,name=locationId,proto3" json:"locationId,omitempty"`
	OperatingAmbit Ambit      `protobuf:"varint,8,opt,name=operatingAmbit,proto3,enum=structs.structs.Ambit" json:"operatingAmbit,omitempty"`
	Slot           uint64     `protobuf:"varint,9,opt,name=slot,proto3" json:"slot,omitempty"`
}

func (m *Struct) Reset()         { *m = Struct{} }
func (m *Struct) String() string { return proto.CompactTextString(m) }
func (*Struct) ProtoMessage()    {}
func (*Struct) Descriptor() ([]byte, []int) {
	return fileDescriptor_c62b965c884df764, []int{0}
}
func (m *Struct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Struct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Struct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Struct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Struct.Merge(m, src)
}
func (m *Struct) XXX_Size() int {
	return m.Size()
}
func (m *Struct) XXX_DiscardUnknown() {
	xxx_messageInfo_Struct.DiscardUnknown(m)
}

var xxx_messageInfo_Struct proto.InternalMessageInfo

func (m *Struct) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Struct) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Struct) GetType() uint64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Struct) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *Struct) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Struct) GetLocationType() ObjectType {
	if m != nil {
		return m.LocationType
	}
	return ObjectType_guild
}

func (m *Struct) GetLocationId() string {
	if m != nil {
		return m.LocationId
	}
	return ""
}

func (m *Struct) GetOperatingAmbit() Ambit {
	if m != nil {
		return m.OperatingAmbit
	}
	return Ambit_none
}

func (m *Struct) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

type StructType struct {
	Id   uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Fundamental attributes
	Category        ObjectType `protobuf:"varint,3,opt,name=category,proto3,enum=structs.structs.ObjectType" json:"category,omitempty"`
	BuildDifficulty uint64     `protobuf:"varint,4,opt,name=buildDifficulty,proto3" json:"buildDifficulty,omitempty"`
	BuildDraw       uint64     `protobuf:"varint,5,opt,name=buildDraw,proto3" json:"buildDraw,omitempty"`
	MaxHealth       uint64     `protobuf:"varint,6,opt,name=maxHealth,proto3" json:"maxHealth,omitempty"`
	PassiveDraw     uint64     `protobuf:"varint,7,opt,name=passiveDraw,proto3" json:"passiveDraw,omitempty"`
	// Details about location and movement
	// TODO move category to here and make it flag based too
	// Replicate what was done for ambits flags
	PossibleAmbit uint64 `protobuf:"varint,8,opt,name=possibleAmbit,proto3" json:"possibleAmbit,omitempty"`
	Movable       bool   `protobuf:"varint,9,opt,name=movable,proto3" json:"movable,omitempty"`
	SlotBound     bool   `protobuf:"varint,10,opt,name=slotBound,proto3" json:"slotBound,omitempty"`
	// Primary Weapon Configuration
	PrimaryWeapon                           TechActiveWeaponry `protobuf:"varint,11,opt,name=primaryWeapon,proto3,enum=structs.structs.TechActiveWeaponry" json:"primaryWeapon,omitempty"`
	PrimaryWeaponControl                    TechWeaponControl  `protobuf:"varint,12,opt,name=primaryWeaponControl,proto3,enum=structs.structs.TechWeaponControl" json:"primaryWeaponControl,omitempty"`
	PrimaryWeaponCharge                     uint64             `protobuf:"varint,13,opt,name=primaryWeaponCharge,proto3" json:"primaryWeaponCharge,omitempty"`
	PrimaryWeaponTargets                    uint64             `protobuf:"varint,14,opt,name=primaryWeaponTargets,proto3" json:"primaryWeaponTargets,omitempty"`
	PrimaryWeaponShots                      uint64             `protobuf:"varint,15,opt,name=primaryWeaponShots,proto3" json:"primaryWeaponShots,omitempty"`
	PrimaryWeaponDamage                     uint64             `protobuf:"varint,16,opt,name=primaryWeaponDamage,proto3" json:"primaryWeaponDamage,omitempty"`
	PrimaryWeaponBlockable                  bool               `protobuf:"varint,17,opt,name=primaryWeaponBlockable,proto3" json:"primaryWeaponBlockable,omitempty"`
	PrimaryWeaponCounterable                bool               `protobuf:"varint,18,opt,name=primaryWeaponCounterable,proto3" json:"primaryWeaponCounterable,omitempty"`
	PrimaryWeaponRecoilDamage               uint64             `protobuf:"varint,19,opt,name=primaryWeaponRecoilDamage,proto3" json:"primaryWeaponRecoilDamage,omitempty"`
	PrimaryWeaponShotSuccessRateNumerator   uint64             `protobuf:"varint,20,opt,name=primaryWeaponShotSuccessRateNumerator,proto3" json:"primaryWeaponShotSuccessRateNumerator,omitempty"`
	PrimaryWeaponShotSuccessRateDenominator uint64             `protobuf:"varint,21,opt,name=primaryWeaponShotSuccessRateDenominator,proto3" json:"primaryWeaponShotSuccessRateDenominator,omitempty"`
	// Secondary Weapon Configuration
	SecondaryWeapon                           TechActiveWeaponry `protobuf:"varint,22,opt,name=secondaryWeapon,proto3,enum=structs.structs.TechActiveWeaponry" json:"secondaryWeapon,omitempty"`
	SecondaryWeaponControl                    TechWeaponControl  `protobuf:"varint,23,opt,name=secondaryWeaponControl,proto3,enum=structs.structs.TechWeaponControl" json:"secondaryWeaponControl,omitempty"`
	SecondaryWeaponCharge                     uint64             `protobuf:"varint,24,opt,name=secondaryWeaponCharge,proto3" json:"secondaryWeaponCharge,omitempty"`
	SecondaryWeaponTargets                    uint64             `protobuf:"varint,25,opt,name=secondaryWeaponTargets,proto3" json:"secondaryWeaponTargets,omitempty"`
	SecondaryWeaponShots                      uint64             `protobuf:"varint,26,opt,name=secondaryWeaponShots,proto3" json:"secondaryWeaponShots,omitempty"`
	SecondaryWeaponDamage                     uint64             `protobuf:"varint,27,opt,name=secondaryWeaponDamage,proto3" json:"secondaryWeaponDamage,omitempty"`
	SecondaryWeaponBlockable                  bool               `protobuf:"varint,28,opt,name=secondaryWeaponBlockable,proto3" json:"secondaryWeaponBlockable,omitempty"`
	SecondaryWeaponCounterable                bool               `protobuf:"varint,29,opt,name=secondaryWeaponCounterable,proto3" json:"secondaryWeaponCounterable,omitempty"`
	SecondaryWeaponRecoilDamage               uint64             `protobuf:"varint,30,opt,name=secondaryWeaponRecoilDamage,proto3" json:"secondaryWeaponRecoilDamage,omitempty"`
	SecondaryWeaponShotSuccessRateNumerator   uint64             `protobuf:"varint,31,opt,name=secondaryWeaponShotSuccessRateNumerator,proto3" json:"secondaryWeaponShotSuccessRateNumerator,omitempty"`
	SecondaryWeaponShotSuccessRateDenominator uint64             `protobuf:"varint,32,opt,name=secondaryWeaponShotSuccessRateDenominator,proto3" json:"secondaryWeaponShotSuccessRateDenominator,omitempty"`
	// Tech Tree Features
	PassiveWeaponry    TechPassiveWeaponry     `protobuf:"varint,33,opt,name=passiveWeaponry,proto3,enum=structs.structs.TechPassiveWeaponry" json:"passiveWeaponry,omitempty"`
	UnitDefenses       TechUnitDefenses        `protobuf:"varint,34,opt,name=unitDefenses,proto3,enum=structs.structs.TechUnitDefenses" json:"unitDefenses,omitempty"`
	OreReserveDefenses TechOreReserveDefenses  `protobuf:"varint,35,opt,name=oreReserveDefenses,proto3,enum=structs.structs.TechOreReserveDefenses" json:"oreReserveDefenses,omitempty"`
	PlanetaryDefenses  TechPlanetaryDefenses   `protobuf:"varint,36,opt,name=planetaryDefenses,proto3,enum=structs.structs.TechPlanetaryDefenses" json:"planetaryDefenses,omitempty"`
	PlanetaryMining    TechPlanetaryMining     `protobuf:"varint,37,opt,name=planetaryMining,proto3,enum=structs.structs.TechPlanetaryMining" json:"planetaryMining,omitempty"`
	PlanetaryRefinery  TechPlanetaryRefineries `protobuf:"varint,38,opt,name=planetaryRefinery,proto3,enum=structs.structs.TechPlanetaryRefineries" json:"planetaryRefinery,omitempty"`
	PowerGeneration    TechPowerGeneration     `protobuf:"varint,39,opt,name=powerGeneration,proto3,enum=structs.structs.TechPowerGeneration" json:"powerGeneration,omitempty"`
	// Charge uses
	ActivateCharge        uint64 `protobuf:"varint,40,opt,name=activateCharge,proto3" json:"activateCharge,omitempty"`
	BuildCharge           uint64 `protobuf:"varint,41,opt,name=buildCharge,proto3" json:"buildCharge,omitempty"`
	DefendChangeCharge    uint64 `protobuf:"varint,42,opt,name=defendChangeCharge,proto3" json:"defendChangeCharge,omitempty"`
	MoveCharge            uint64 `protobuf:"varint,43,opt,name=moveCharge,proto3" json:"moveCharge,omitempty"`
	OreMiningCharge       uint64 `protobuf:"varint,44,opt,name=oreMiningCharge,proto3" json:"oreMiningCharge,omitempty"`
	OreRefiningCharge     uint64 `protobuf:"varint,45,opt,name=oreRefiningCharge,proto3" json:"oreRefiningCharge,omitempty"`
	StealthActivateCharge uint64 `protobuf:"varint,46,opt,name=stealthActivateCharge,proto3" json:"stealthActivateCharge,omitempty"`
	// Tech Tree Attributes
	AttackReduction                         uint64 `protobuf:"varint,47,opt,name=attackReduction,proto3" json:"attackReduction,omitempty"`
	AttackCounterable                       bool   `protobuf:"varint,48,opt,name=attackCounterable,proto3" json:"attackCounterable,omitempty"`
	StealthSystems                          bool   `protobuf:"varint,49,opt,name=stealthSystems,proto3" json:"stealthSystems,omitempty"`
	CounterAttack                           uint64 `protobuf:"varint,50,opt,name=counterAttack,proto3" json:"counterAttack,omitempty"`
	CounterAttackSameAmbit                  uint64 `protobuf:"varint,51,opt,name=counterAttackSameAmbit,proto3" json:"counterAttackSameAmbit,omitempty"`
	PostDestructionDamage                   uint64 `protobuf:"varint,52,opt,name=postDestructionDamage,proto3" json:"postDestructionDamage,omitempty"`
	GeneratingRate                          uint64 `protobuf:"varint,53,opt,name=generatingRate,proto3" json:"generatingRate,omitempty"`
	PlanetaryShieldContribution             uint64 `protobuf:"varint,54,opt,name=planetaryShieldContribution,proto3" json:"planetaryShieldContribution,omitempty"`
	UnguidedDefensiveSuccessRateNumerator   uint64 `protobuf:"varint,55,opt,name=unguidedDefensiveSuccessRateNumerator,proto3" json:"unguidedDefensiveSuccessRateNumerator,omitempty"`
	UnguidedDefensiveSuccessRateDenominator uint64 `protobuf:"varint,56,opt,name=unguidedDefensiveSuccessRateDenominator,proto3" json:"unguidedDefensiveSuccessRateDenominator,omitempty"`
	GuidedDefensiveSuccessRateNumerator     uint64 `protobuf:"varint,57,opt,name=guidedDefensiveSuccessRateNumerator,proto3" json:"guidedDefensiveSuccessRateNumerator,omitempty"`
	GuidedDefensiveSuccessRateDenominator   uint64 `protobuf:"varint,58,opt,name=guidedDefensiveSuccessRateDenominator,proto3" json:"guidedDefensiveSuccessRateDenominator,omitempty"`
}

func (m *StructType) Reset()         { *m = StructType{} }
func (m *StructType) String() string { return proto.CompactTextString(m) }
func (*StructType) ProtoMessage()    {}
func (*StructType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c62b965c884df764, []int{1}
}
func (m *StructType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StructType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StructType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StructType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StructType.Merge(m, src)
}
func (m *StructType) XXX_Size() int {
	return m.Size()
}
func (m *StructType) XXX_DiscardUnknown() {
	xxx_messageInfo_StructType.DiscardUnknown(m)
}

var xxx_messageInfo_StructType proto.InternalMessageInfo

func (m *StructType) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StructType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *StructType) GetCategory() ObjectType {
	if m != nil {
		return m.Category
	}
	return ObjectType_guild
}

func (m *StructType) GetBuildDifficulty() uint64 {
	if m != nil {
		return m.BuildDifficulty
	}
	return 0
}

func (m *StructType) GetBuildDraw() uint64 {
	if m != nil {
		return m.BuildDraw
	}
	return 0
}

func (m *StructType) GetMaxHealth() uint64 {
	if m != nil {
		return m.MaxHealth
	}
	return 0
}

func (m *StructType) GetPassiveDraw() uint64 {
	if m != nil {
		return m.PassiveDraw
	}
	return 0
}

func (m *StructType) GetPossibleAmbit() uint64 {
	if m != nil {
		return m.PossibleAmbit
	}
	return 0
}

func (m *StructType) GetMovable() bool {
	if m != nil {
		return m.Movable
	}
	return false
}

func (m *StructType) GetSlotBound() bool {
	if m != nil {
		return m.SlotBound
	}
	return false
}

func (m *StructType) GetPrimaryWeapon() TechActiveWeaponry {
	if m != nil {
		return m.PrimaryWeapon
	}
	return TechActiveWeaponry_noActiveWeaponry
}

func (m *StructType) GetPrimaryWeaponControl() TechWeaponControl {
	if m != nil {
		return m.PrimaryWeaponControl
	}
	return TechWeaponControl_noWeaponControl
}

func (m *StructType) GetPrimaryWeaponCharge() uint64 {
	if m != nil {
		return m.PrimaryWeaponCharge
	}
	return 0
}

func (m *StructType) GetPrimaryWeaponTargets() uint64 {
	if m != nil {
		return m.PrimaryWeaponTargets
	}
	return 0
}

func (m *StructType) GetPrimaryWeaponShots() uint64 {
	if m != nil {
		return m.PrimaryWeaponShots
	}
	return 0
}

func (m *StructType) GetPrimaryWeaponDamage() uint64 {
	if m != nil {
		return m.PrimaryWeaponDamage
	}
	return 0
}

func (m *StructType) GetPrimaryWeaponBlockable() bool {
	if m != nil {
		return m.PrimaryWeaponBlockable
	}
	return false
}

func (m *StructType) GetPrimaryWeaponCounterable() bool {
	if m != nil {
		return m.PrimaryWeaponCounterable
	}
	return false
}

func (m *StructType) GetPrimaryWeaponRecoilDamage() uint64 {
	if m != nil {
		return m.PrimaryWeaponRecoilDamage
	}
	return 0
}

func (m *StructType) GetPrimaryWeaponShotSuccessRateNumerator() uint64 {
	if m != nil {
		return m.PrimaryWeaponShotSuccessRateNumerator
	}
	return 0
}

func (m *StructType) GetPrimaryWeaponShotSuccessRateDenominator() uint64 {
	if m != nil {
		return m.PrimaryWeaponShotSuccessRateDenominator
	}
	return 0
}

func (m *StructType) GetSecondaryWeapon() TechActiveWeaponry {
	if m != nil {
		return m.SecondaryWeapon
	}
	return TechActiveWeaponry_noActiveWeaponry
}

func (m *StructType) GetSecondaryWeaponControl() TechWeaponControl {
	if m != nil {
		return m.SecondaryWeaponControl
	}
	return TechWeaponControl_noWeaponControl
}

func (m *StructType) GetSecondaryWeaponCharge() uint64 {
	if m != nil {
		return m.SecondaryWeaponCharge
	}
	return 0
}

func (m *StructType) GetSecondaryWeaponTargets() uint64 {
	if m != nil {
		return m.SecondaryWeaponTargets
	}
	return 0
}

func (m *StructType) GetSecondaryWeaponShots() uint64 {
	if m != nil {
		return m.SecondaryWeaponShots
	}
	return 0
}

func (m *StructType) GetSecondaryWeaponDamage() uint64 {
	if m != nil {
		return m.SecondaryWeaponDamage
	}
	return 0
}

func (m *StructType) GetSecondaryWeaponBlockable() bool {
	if m != nil {
		return m.SecondaryWeaponBlockable
	}
	return false
}

func (m *StructType) GetSecondaryWeaponCounterable() bool {
	if m != nil {
		return m.SecondaryWeaponCounterable
	}
	return false
}

func (m *StructType) GetSecondaryWeaponRecoilDamage() uint64 {
	if m != nil {
		return m.SecondaryWeaponRecoilDamage
	}
	return 0
}

func (m *StructType) GetSecondaryWeaponShotSuccessRateNumerator() uint64 {
	if m != nil {
		return m.SecondaryWeaponShotSuccessRateNumerator
	}
	return 0
}

func (m *StructType) GetSecondaryWeaponShotSuccessRateDenominator() uint64 {
	if m != nil {
		return m.SecondaryWeaponShotSuccessRateDenominator
	}
	return 0
}

func (m *StructType) GetPassiveWeaponry() TechPassiveWeaponry {
	if m != nil {
		return m.PassiveWeaponry
	}
	return TechPassiveWeaponry_noPassiveWeaponry
}

func (m *StructType) GetUnitDefenses() TechUnitDefenses {
	if m != nil {
		return m.UnitDefenses
	}
	return TechUnitDefenses_noUnitDefenses
}

func (m *StructType) GetOreReserveDefenses() TechOreReserveDefenses {
	if m != nil {
		return m.OreReserveDefenses
	}
	return TechOreReserveDefenses_noOreReserveDefenses
}

func (m *StructType) GetPlanetaryDefenses() TechPlanetaryDefenses {
	if m != nil {
		return m.PlanetaryDefenses
	}
	return TechPlanetaryDefenses_noPlanetaryDefense
}

func (m *StructType) GetPlanetaryMining() TechPlanetaryMining {
	if m != nil {
		return m.PlanetaryMining
	}
	return TechPlanetaryMining_noPlanetaryMining
}

func (m *StructType) GetPlanetaryRefinery() TechPlanetaryRefineries {
	if m != nil {
		return m.PlanetaryRefinery
	}
	return TechPlanetaryRefineries_noPlanetaryRefinery
}

func (m *StructType) GetPowerGeneration() TechPowerGeneration {
	if m != nil {
		return m.PowerGeneration
	}
	return TechPowerGeneration_noPowerGeneration
}

func (m *StructType) GetActivateCharge() uint64 {
	if m != nil {
		return m.ActivateCharge
	}
	return 0
}

func (m *StructType) GetBuildCharge() uint64 {
	if m != nil {
		return m.BuildCharge
	}
	return 0
}

func (m *StructType) GetDefendChangeCharge() uint64 {
	if m != nil {
		return m.DefendChangeCharge
	}
	return 0
}

func (m *StructType) GetMoveCharge() uint64 {
	if m != nil {
		return m.MoveCharge
	}
	return 0
}

func (m *StructType) GetOreMiningCharge() uint64 {
	if m != nil {
		return m.OreMiningCharge
	}
	return 0
}

func (m *StructType) GetOreRefiningCharge() uint64 {
	if m != nil {
		return m.OreRefiningCharge
	}
	return 0
}

func (m *StructType) GetStealthActivateCharge() uint64 {
	if m != nil {
		return m.StealthActivateCharge
	}
	return 0
}

func (m *StructType) GetAttackReduction() uint64 {
	if m != nil {
		return m.AttackReduction
	}
	return 0
}

func (m *StructType) GetAttackCounterable() bool {
	if m != nil {
		return m.AttackCounterable
	}
	return false
}

func (m *StructType) GetStealthSystems() bool {
	if m != nil {
		return m.StealthSystems
	}
	return false
}

func (m *StructType) GetCounterAttack() uint64 {
	if m != nil {
		return m.CounterAttack
	}
	return 0
}

func (m *StructType) GetCounterAttackSameAmbit() uint64 {
	if m != nil {
		return m.CounterAttackSameAmbit
	}
	return 0
}

func (m *StructType) GetPostDestructionDamage() uint64 {
	if m != nil {
		return m.PostDestructionDamage
	}
	return 0
}

func (m *StructType) GetGeneratingRate() uint64 {
	if m != nil {
		return m.GeneratingRate
	}
	return 0
}

func (m *StructType) GetPlanetaryShieldContribution() uint64 {
	if m != nil {
		return m.PlanetaryShieldContribution
	}
	return 0
}

func (m *StructType) GetUnguidedDefensiveSuccessRateNumerator() uint64 {
	if m != nil {
		return m.UnguidedDefensiveSuccessRateNumerator
	}
	return 0
}

func (m *StructType) GetUnguidedDefensiveSuccessRateDenominator() uint64 {
	if m != nil {
		return m.UnguidedDefensiveSuccessRateDenominator
	}
	return 0
}

func (m *StructType) GetGuidedDefensiveSuccessRateNumerator() uint64 {
	if m != nil {
		return m.GuidedDefensiveSuccessRateNumerator
	}
	return 0
}

func (m *StructType) GetGuidedDefensiveSuccessRateDenominator() uint64 {
	if m != nil {
		return m.GuidedDefensiveSuccessRateDenominator
	}
	return 0
}

type StructDefender struct {
	ProtectedStructId      string     `protobuf:"bytes,1,opt,name=protectedStructId,proto3" json:"protectedStructId,omitempty"`
	DefendingStructId      string     `protobuf:"bytes,2,opt,name=defendingStructId,proto3" json:"defendingStructId,omitempty"`
	LocationType           ObjectType `protobuf:"varint,3,opt,name=locationType,proto3,enum=structs.structs.ObjectType" json:"locationType,omitempty"`
	LocationId             string     `protobuf:"bytes,4,opt,name=locationId,proto3" json:"locationId,omitempty"`
	OperatingAmbit         Ambit      `protobuf:"varint,5,opt,name=operatingAmbit,proto3,enum=structs.structs.Ambit" json:"operatingAmbit,omitempty"`
	CounterAttack          uint64     `protobuf:"varint,6,opt,name=counterAttack,proto3" json:"counterAttack,omitempty"`
	CounterAttackSameAmbit uint64     `protobuf:"varint,7,opt,name=counterAttackSameAmbit,proto3" json:"counterAttackSameAmbit,omitempty"`
}

func (m *StructDefender) Reset()         { *m = StructDefender{} }
func (m *StructDefender) String() string { return proto.CompactTextString(m) }
func (*StructDefender) ProtoMessage()    {}
func (*StructDefender) Descriptor() ([]byte, []int) {
	return fileDescriptor_c62b965c884df764, []int{2}
}
func (m *StructDefender) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StructDefender) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StructDefender.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StructDefender) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StructDefender.Merge(m, src)
}
func (m *StructDefender) XXX_Size() int {
	return m.Size()
}
func (m *StructDefender) XXX_DiscardUnknown() {
	xxx_messageInfo_StructDefender.DiscardUnknown(m)
}

var xxx_messageInfo_StructDefender proto.InternalMessageInfo

func (m *StructDefender) GetProtectedStructId() string {
	if m != nil {
		return m.ProtectedStructId
	}
	return ""
}

func (m *StructDefender) GetDefendingStructId() string {
	if m != nil {
		return m.DefendingStructId
	}
	return ""
}

func (m *StructDefender) GetLocationType() ObjectType {
	if m != nil {
		return m.LocationType
	}
	return ObjectType_guild
}

func (m *StructDefender) GetLocationId() string {
	if m != nil {
		return m.LocationId
	}
	return ""
}

func (m *StructDefender) GetOperatingAmbit() Ambit {
	if m != nil {
		return m.OperatingAmbit
	}
	return Ambit_none
}

func (m *StructDefender) GetCounterAttack() uint64 {
	if m != nil {
		return m.CounterAttack
	}
	return 0
}

func (m *StructDefender) GetCounterAttackSameAmbit() uint64 {
	if m != nil {
		return m.CounterAttackSameAmbit
	}
	return 0
}

type StructAttributeRecord struct {
	AttributeId string `protobuf:"bytes,1,opt,name=attributeId,proto3" json:"attributeId,omitempty"`
	Value       uint64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *StructAttributeRecord) Reset()         { *m = StructAttributeRecord{} }
func (m *StructAttributeRecord) String() string { return proto.CompactTextString(m) }
func (*StructAttributeRecord) ProtoMessage()    {}
func (*StructAttributeRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_c62b965c884df764, []int{3}
}
func (m *StructAttributeRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StructAttributeRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StructAttributeRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StructAttributeRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StructAttributeRecord.Merge(m, src)
}
func (m *StructAttributeRecord) XXX_Size() int {
	return m.Size()
}
func (m *StructAttributeRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_StructAttributeRecord.DiscardUnknown(m)
}

var xxx_messageInfo_StructAttributeRecord proto.InternalMessageInfo

func (m *StructAttributeRecord) GetAttributeId() string {
	if m != nil {
		return m.AttributeId
	}
	return ""
}

func (m *StructAttributeRecord) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func init() {
	proto.RegisterType((*Struct)(nil), "structs.structs.Struct")
	proto.RegisterType((*StructType)(nil), "structs.structs.StructType")
	proto.RegisterType((*StructDefender)(nil), "structs.structs.StructDefender")
	proto.RegisterType((*StructAttributeRecord)(nil), "structs.structs.StructAttributeRecord")
}

func init() { proto.RegisterFile("structs/structs/struct.proto", fileDescriptor_c62b965c884df764) }

var fileDescriptor_c62b965c884df764 = []byte{
	// 1296 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0xae, 0x5d, 0x37, 0x69, 0xb7, 0xad, 0x43, 0xb7, 0x49, 0xba, 0x4d, 0x82, 0x49, 0x9d, 0x34,
	0x71, 0xa1, 0xb8, 0x6d, 0x5a, 0x5a, 0xc8, 0x30, 0x85, 0x84, 0x30, 0x90, 0x8b, 0xfe, 0x8c, 0x1c,
	0x5a, 0xa6, 0xc3, 0xcd, 0x5a, 0x3a, 0x71, 0x96, 0xc8, 0x5a, 0x8f, 0xb4, 0x72, 0xe2, 0xb7, 0xe0,
	0x2d, 0x78, 0x15, 0x2e, 0xcb, 0x1d, 0x97, 0x4c, 0x72, 0xc9, 0x4b, 0x30, 0x7b, 0x56, 0xb2, 0xad,
	0x1f, 0x1b, 0x75, 0xb8, 0x4a, 0xf4, 0x9d, 0xef, 0x1c, 0x1d, 0x7d, 0xfe, 0xf6, 0x68, 0x57, 0x64,
	0x25, 0x50, 0x7e, 0x68, 0xab, 0xe0, 0x41, 0xf2, 0x6f, 0xb3, 0xe7, 0x4b, 0x25, 0xe9, 0x5c, 0x84,
	0x36, 0xa3, 0xbf, 0x4b, 0x4b, 0x69, 0xfa, 0x31, 0x0c, 0x02, 0x43, 0xae, 0xff, 0x5e, 0x26, 0x33,
	0x2d, 0x84, 0x69, 0x95, 0x94, 0x85, 0xc3, 0x4a, 0xab, 0xa5, 0xc6, 0x15, 0xab, 0x2c, 0x1c, 0x3a,
	0x4f, 0x2e, 0x09, 0xcf, 0x81, 0x53, 0x56, 0x5e, 0x2d, 0x35, 0x2a, 0x96, 0xb9, 0xa0, 0x94, 0x54,
	0xd4, 0xa0, 0x07, 0xec, 0x22, 0x82, 0xf8, 0x3f, 0x65, 0x64, 0xd6, 0xf6, 0x81, 0x2b, 0xe9, 0xb3,
	0x0a, 0xa6, 0xc7, 0x97, 0xba, 0x86, 0x3c, 0xf1, 0xc0, 0x67, 0x97, 0x10, 0x37, 0x17, 0xf4, 0x1b,
	0x72, 0xcd, 0x95, 0x36, 0x57, 0x42, 0x7a, 0x07, 0xba, 0xd6, 0xcc, 0x6a, 0xa9, 0x51, 0xdd, 0x5a,
	0x6e, 0xa6, 0x1a, 0x6f, 0xca, 0xf6, 0xaf, 0x60, 0x2b, 0x4d, 0xb1, 0x12, 0x09, 0xb4, 0x46, 0x48,
	0x7c, 0xbd, 0xef, 0xb0, 0x59, 0xac, 0x3d, 0x86, 0xd0, 0xe7, 0xa4, 0x2a, 0x7b, 0xe0, 0x73, 0x25,
	0xbc, 0xce, 0x4e, 0xb7, 0x2d, 0x14, 0xbb, 0x8c, 0xb7, 0x58, 0xcc, 0xdc, 0x82, 0xeb, 0xa8, 0x95,
	0x62, 0xeb, 0x87, 0x0c, 0x5c, 0xa9, 0xd8, 0x15, 0xf3, 0x90, 0xfa, 0xff, 0xfa, 0x9f, 0x4b, 0x84,
	0x18, 0xa5, 0xb0, 0x85, 0x91, 0x5a, 0x15, 0x54, 0x2b, 0xd6, 0xa5, 0x8c, 0xcd, 0x18, 0x5d, 0x9e,
	0x91, 0xcb, 0x36, 0x57, 0xd0, 0x91, 0xfe, 0x00, 0xf5, 0xfa, 0x8f, 0x67, 0x1c, 0x92, 0x69, 0x83,
	0xcc, 0xb5, 0x43, 0xe1, 0x3a, 0x7b, 0xe2, 0xf0, 0x50, 0xd8, 0xa1, 0xab, 0x06, 0x28, 0x6c, 0xc5,
	0x4a, 0xc3, 0x74, 0x85, 0x5c, 0x31, 0x90, 0xcf, 0x4f, 0x50, 0xe4, 0x8a, 0x35, 0x02, 0x74, 0xb4,
	0xcb, 0x4f, 0x7f, 0x04, 0xee, 0xaa, 0x23, 0x54, 0xb9, 0x62, 0x8d, 0x00, 0xba, 0x4a, 0xae, 0xf6,
	0x78, 0x10, 0x88, 0x3e, 0x60, 0xf6, 0x2c, 0xc6, 0xc7, 0x21, 0xba, 0x4e, 0xae, 0xf7, 0x64, 0x10,
	0x88, 0xb6, 0x0b, 0x23, 0x19, 0x2b, 0x56, 0x12, 0xd4, 0x3f, 0x7f, 0x57, 0xf6, 0x79, 0xdb, 0x05,
	0x14, 0xec, 0xb2, 0x15, 0x5f, 0xea, 0xfb, 0x6b, 0xed, 0x76, 0x65, 0xe8, 0x39, 0x8c, 0x60, 0x6c,
	0x04, 0xd0, 0x7d, 0x72, 0xbd, 0xe7, 0x8b, 0x2e, 0xf7, 0x07, 0x6f, 0x81, 0xf7, 0xa4, 0xc7, 0xae,
	0xa2, 0x46, 0x6b, 0x19, 0x8d, 0x14, 0xd8, 0x47, 0x3b, 0xb6, 0x12, 0x7d, 0x30, 0x44, 0x7f, 0x60,
	0x25, 0x33, 0xe9, 0x1b, 0x32, 0x9f, 0x00, 0xbe, 0x93, 0x9e, 0xf2, 0xa5, 0xcb, 0xae, 0x61, 0xc5,
	0x7a, 0x6e, 0xc5, 0x04, 0xd3, 0xca, 0xcd, 0xa7, 0x0f, 0xc9, 0xcd, 0x24, 0x7e, 0xc4, 0xfd, 0x0e,
	0xb0, 0xeb, 0x28, 0x43, 0x5e, 0x88, 0x6e, 0xa5, 0x3a, 0x39, 0xd0, 0xa8, 0x0a, 0x58, 0x15, 0x53,
	0x72, 0x63, 0xb4, 0x49, 0x68, 0x02, 0x6f, 0x1d, 0x49, 0x15, 0xb0, 0x39, 0xcc, 0xc8, 0x89, 0x64,
	0xba, 0xda, 0xe3, 0x5d, 0xde, 0x01, 0xf6, 0x51, 0x4e, 0x57, 0x26, 0x44, 0x9f, 0x92, 0xc5, 0x04,
	0xbc, 0xeb, 0x4a, 0xfb, 0x18, 0x7f, 0xb1, 0x1b, 0xf8, 0xab, 0x4c, 0x88, 0xd2, 0x6d, 0xc2, 0x52,
	0xba, 0x84, 0x9e, 0x02, 0x1f, 0x33, 0x29, 0x66, 0x4e, 0x8c, 0xd3, 0xaf, 0xc9, 0xed, 0x44, 0xcc,
	0x02, 0x5b, 0x0a, 0x37, 0xea, 0xf5, 0x26, 0xf6, 0x3a, 0x99, 0x40, 0x0f, 0xc8, 0xdd, 0xcc, 0x93,
	0xb7, 0x42, 0xdb, 0x86, 0x20, 0xb0, 0xb8, 0x82, 0x97, 0x61, 0x57, 0xaf, 0x58, 0xe9, 0xb3, 0x79,
	0xac, 0x54, 0x8c, 0x4c, 0x7f, 0x26, 0x9b, 0xd3, 0x88, 0x7b, 0xe0, 0xc9, 0xae, 0xf0, 0xb0, 0xee,
	0x02, 0xd6, 0x2d, 0x4a, 0xa7, 0x2f, 0xc8, 0x5c, 0x00, 0xb6, 0xf4, 0x9c, 0x91, 0x9d, 0x17, 0x8b,
	0xdb, 0x39, 0x9d, 0x4b, 0xdf, 0x91, 0xc5, 0x14, 0x14, 0x5b, 0xfa, 0x56, 0x61, 0x4b, 0x4f, 0xa8,
	0x40, 0x9f, 0x90, 0x85, 0x74, 0xc4, 0xd8, 0x9a, 0xe1, 0x23, 0xe7, 0x07, 0xb5, 0x85, 0x52, 0x81,
	0xd8, 0xda, 0xb7, 0x31, 0x6d, 0x42, 0x54, 0x2f, 0x88, 0x54, 0xc4, 0xd8, 0x7b, 0xc9, 0x2c, 0x88,
	0xbc, 0x58, 0x4e, 0x87, 0x91, 0x6d, 0x96, 0x73, 0x3b, 0x8c, 0x2c, 0xb3, 0x4d, 0x58, 0x2a, 0x30,
	0xb2, 0xf9, 0x8a, 0x31, 0xeb, 0xa4, 0x38, 0x7d, 0x4e, 0x96, 0x32, 0x6a, 0x8d, 0xac, 0xfe, 0x31,
	0x66, 0x4f, 0x61, 0xd0, 0x6f, 0xc9, 0x72, 0x2a, 0x9a, 0xb0, 0x7b, 0x0d, 0xfb, 0x9e, 0x46, 0xd1,
	0xd6, 0xcc, 0xd1, 0x22, 0xd7, 0xf2, 0x9f, 0x18, 0x6b, 0x16, 0xa4, 0xd3, 0x5f, 0xc8, 0xbd, 0xe9,
	0xd4, 0x71, 0xdb, 0xaf, 0x62, 0xed, 0xe2, 0x09, 0xf4, 0x25, 0x99, 0x8b, 0x5e, 0x19, 0xb1, 0x9b,
	0xd9, 0x1d, 0xb4, 0xe8, 0x7a, 0xae, 0x45, 0x5f, 0x27, 0xb9, 0x56, 0x3a, 0x99, 0x7e, 0x4f, 0xae,
	0x85, 0x9e, 0x50, 0x7b, 0x70, 0x08, 0x5e, 0x00, 0x01, 0xab, 0x63, 0xb1, 0x3b, 0xb9, 0xc5, 0x7e,
	0x1a, 0x23, 0x5a, 0x89, 0x34, 0xfa, 0x96, 0x50, 0xe9, 0x83, 0x05, 0x01, 0xf8, 0x7d, 0x18, 0x16,
	0x5b, 0xc3, 0x62, 0x9b, 0xb9, 0xc5, 0x5e, 0x65, 0xe8, 0x56, 0x4e, 0x09, 0x7a, 0x40, 0x6e, 0xf4,
	0x5c, 0xee, 0x81, 0xe2, 0xfe, 0x60, 0x58, 0x77, 0x1d, 0xeb, 0x6e, 0xe4, 0x3f, 0x71, 0x9a, 0x6d,
	0x65, 0x0b, 0xa0, 0x8a, 0x31, 0xf8, 0x42, 0x78, 0xc2, 0xeb, 0xb0, 0xbb, 0xd3, 0x54, 0x4c, 0x72,
	0xad, 0x74, 0x32, 0x7d, 0x33, 0xd6, 0xa5, 0x05, 0x87, 0xc2, 0x03, 0x7f, 0xc0, 0x36, 0xb0, 0x62,
	0x63, 0x7a, 0xc5, 0x88, 0x2d, 0x12, 0x7d, 0xc6, 0x25, 0xb0, 0x4f, 0x79, 0x02, 0xfe, 0x0f, 0xe0,
	0xe1, 0x8e, 0x49, 0x7a, 0x6c, 0x73, 0x5a, 0x9f, 0x49, 0xae, 0x95, 0x4e, 0xa6, 0x1b, 0xa4, 0xca,
	0xf5, 0x28, 0xe4, 0x0a, 0xa2, 0x21, 0xd4, 0x40, 0x03, 0xa6, 0x50, 0xbd, 0x57, 0xc1, 0x6d, 0x4d,
	0x44, 0xba, 0x67, 0xf6, 0x2a, 0x63, 0x90, 0x7e, 0x89, 0x3a, 0x5a, 0x4d, 0x7d, 0xed, 0x75, 0xe2,
	0x6a, 0x9f, 0x9a, 0x97, 0x68, 0x36, 0xa2, 0xf7, 0x90, 0x5d, 0xd9, 0x8f, 0x79, 0x9f, 0x21, 0x6f,
	0x0c, 0xd1, 0x7b, 0x30, 0xe9, 0x83, 0x91, 0x33, 0x22, 0xdd, 0x37, 0x7b, 0xb0, 0x14, 0x4c, 0xef,
	0x93, 0x1b, 0xe8, 0x93, 0xc3, 0x71, 0xee, 0xe7, 0xc8, 0xcd, 0x06, 0x70, 0xb6, 0x29, 0xdc, 0x80,
	0xed, 0x24, 0x1f, 0xbc, 0x19, 0xcd, 0xb6, 0xbc, 0xa0, 0xee, 0x86, 0x2b, 0xc5, 0xed, 0x63, 0x0b,
	0x9c, 0xd0, 0x46, 0xdd, 0x1f, 0x98, 0x6e, 0x52, 0xb0, 0xee, 0xc6, 0x40, 0xe3, 0x03, 0xec, 0x21,
	0x0e, 0xb0, 0x6c, 0x40, 0xeb, 0x1f, 0xdd, 0xb0, 0x35, 0x08, 0x14, 0x74, 0x03, 0xf6, 0x08, 0xa9,
	0x29, 0x54, 0xef, 0x04, 0x6d, 0x93, 0xb6, 0x83, 0x35, 0xd8, 0x96, 0xd9, 0x09, 0x26, 0x40, 0xfd,
	0x8e, 0x48, 0x00, 0x2d, 0xde, 0x8d, 0x36, 0x8e, 0x8f, 0xcd, 0x3b, 0x22, 0x3f, 0xaa, 0x35, 0xe9,
	0xc9, 0x40, 0xed, 0x81, 0xf1, 0x8e, 0x18, 0xce, 0xfb, 0x27, 0x46, 0x93, 0xdc, 0xa0, 0xee, 0xbd,
	0x13, 0x39, 0xc9, 0xeb, 0xe8, 0xb1, 0xc4, 0xbe, 0x30, 0xde, 0x49, 0xa2, 0x7a, 0x36, 0x0f, 0x8d,
	0xdc, 0x3a, 0x12, 0xe0, 0x3a, 0xf8, 0x26, 0x14, 0xed, 0x10, 0x75, 0x7c, 0x6a, 0x66, 0xf3, 0x14,
	0x8a, 0xde, 0x8c, 0x84, 0x5e, 0x27, 0x14, 0x0e, 0x38, 0x66, 0xc5, 0x8a, 0x3e, 0xe4, 0x4e, 0xe6,
	0x67, 0x66, 0x33, 0x52, 0x88, 0xac, 0x27, 0xfe, 0x34, 0xe2, 0xf8, 0x54, 0xfe, 0xd2, 0x4c, 0xfc,
	0x82, 0x74, 0xfa, 0x9a, 0xac, 0x15, 0xe9, 0xf6, 0x2b, 0xac, 0x5a, 0x84, 0xaa, 0x15, 0x28, 0xd6,
	0xe9, 0xb6, 0x51, 0xa0, 0x10, 0xb9, 0xfe, 0x4f, 0x99, 0x54, 0xcd, 0x99, 0x0a, 0x99, 0x0e, 0xf8,
	0xda, 0xbe, 0xfa, 0x64, 0x0a, 0xb6, 0x02, 0xc7, 0x84, 0xf6, 0xe3, 0x43, 0x69, 0x36, 0xa0, 0xd9,
	0x66, 0x69, 0x0b, 0xaf, 0x33, 0x64, 0x9b, 0x23, 0x58, 0x36, 0x90, 0x39, 0x77, 0x5e, 0xfc, 0x7f,
	0xe7, 0xce, 0x4a, 0x81, 0x73, 0xe7, 0xa5, 0x0f, 0x3a, 0x77, 0x66, 0x56, 0xd9, 0xcc, 0x87, 0xad,
	0xb2, 0xd9, 0x69, 0xab, 0xac, 0xfe, 0x8a, 0x2c, 0x18, 0x29, 0x76, 0x94, 0xb1, 0x36, 0xe8, 0x0d,
	0x88, 0xef, 0xe8, 0xe1, 0xca, 0x63, 0x68, 0xa8, 0xf6, 0x38, 0xa4, 0xcf, 0xf1, 0x7d, 0xee, 0x86,
	0x10, 0x7f, 0x0b, 0xc0, 0x8b, 0xdd, 0x47, 0x7f, 0x9c, 0xd5, 0x4a, 0xef, 0xcf, 0x6a, 0xa5, 0xbf,
	0xcf, 0x6a, 0xa5, 0xdf, 0xce, 0x6b, 0x17, 0xde, 0x9f, 0xd7, 0x2e, 0xfc, 0x75, 0x5e, 0xbb, 0xf0,
	0xee, 0x56, 0xfc, 0xa9, 0xe1, 0x74, 0xf8, 0xd1, 0x41, 0x9f, 0x88, 0x83, 0xf6, 0x0c, 0x7e, 0x76,
	0x78, 0xfc, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe9, 0xb6, 0x76, 0x34, 0xc3, 0x10, 0x00, 0x00,
}

func (m *Struct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Struct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Struct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Slot != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x48
	}
	if m.OperatingAmbit != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.OperatingAmbit))
		i--
		dAtA[i] = 0x40
	}
	if len(m.LocationId) > 0 {
		i -= len(m.LocationId)
		copy(dAtA[i:], m.LocationId)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.LocationId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.LocationType != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.LocationType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StructType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StructType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StructType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GuidedDefensiveSuccessRateDenominator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.GuidedDefensiveSuccessRateDenominator))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.GuidedDefensiveSuccessRateNumerator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.GuidedDefensiveSuccessRateNumerator))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.UnguidedDefensiveSuccessRateDenominator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.UnguidedDefensiveSuccessRateDenominator))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.UnguidedDefensiveSuccessRateNumerator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.UnguidedDefensiveSuccessRateNumerator))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.PlanetaryShieldContribution != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PlanetaryShieldContribution))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.GeneratingRate != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.GeneratingRate))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.PostDestructionDamage != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PostDestructionDamage))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.CounterAttackSameAmbit != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.CounterAttackSameAmbit))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.CounterAttack != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.CounterAttack))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.StealthSystems {
		i--
		if m.StealthSystems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.AttackCounterable {
		i--
		if m.AttackCounterable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.AttackReduction != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.AttackReduction))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.StealthActivateCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.StealthActivateCharge))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.OreRefiningCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.OreRefiningCharge))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.OreMiningCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.OreMiningCharge))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.MoveCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.MoveCharge))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.DefendChangeCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.DefendChangeCharge))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.BuildCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.BuildCharge))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ActivateCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.ActivateCharge))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.PowerGeneration != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PowerGeneration))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.PlanetaryRefinery != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PlanetaryRefinery))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.PlanetaryMining != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PlanetaryMining))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.PlanetaryDefenses != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PlanetaryDefenses))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.OreReserveDefenses != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.OreReserveDefenses))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.UnitDefenses != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.UnitDefenses))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.PassiveWeaponry != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PassiveWeaponry))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.SecondaryWeaponShotSuccessRateDenominator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponShotSuccessRateDenominator))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.SecondaryWeaponShotSuccessRateNumerator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponShotSuccessRateNumerator))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.SecondaryWeaponRecoilDamage != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponRecoilDamage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.SecondaryWeaponCounterable {
		i--
		if m.SecondaryWeaponCounterable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.SecondaryWeaponBlockable {
		i--
		if m.SecondaryWeaponBlockable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.SecondaryWeaponDamage != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponDamage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.SecondaryWeaponShots != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponShots))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.SecondaryWeaponTargets != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponTargets))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.SecondaryWeaponCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponCharge))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.SecondaryWeaponControl != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeaponControl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.SecondaryWeapon != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.SecondaryWeapon))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.PrimaryWeaponShotSuccessRateDenominator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponShotSuccessRateDenominator))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.PrimaryWeaponShotSuccessRateNumerator != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponShotSuccessRateNumerator))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PrimaryWeaponRecoilDamage != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponRecoilDamage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.PrimaryWeaponCounterable {
		i--
		if m.PrimaryWeaponCounterable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.PrimaryWeaponBlockable {
		i--
		if m.PrimaryWeaponBlockable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PrimaryWeaponDamage != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponDamage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PrimaryWeaponShots != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponShots))
		i--
		dAtA[i] = 0x78
	}
	if m.PrimaryWeaponTargets != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponTargets))
		i--
		dAtA[i] = 0x70
	}
	if m.PrimaryWeaponCharge != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponCharge))
		i--
		dAtA[i] = 0x68
	}
	if m.PrimaryWeaponControl != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeaponControl))
		i--
		dAtA[i] = 0x60
	}
	if m.PrimaryWeapon != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PrimaryWeapon))
		i--
		dAtA[i] = 0x58
	}
	if m.SlotBound {
		i--
		if m.SlotBound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Movable {
		i--
		if m.Movable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.PossibleAmbit != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PossibleAmbit))
		i--
		dAtA[i] = 0x40
	}
	if m.PassiveDraw != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.PassiveDraw))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxHealth != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.MaxHealth))
		i--
		dAtA[i] = 0x30
	}
	if m.BuildDraw != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.BuildDraw))
		i--
		dAtA[i] = 0x28
	}
	if m.BuildDifficulty != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.BuildDifficulty))
		i--
		dAtA[i] = 0x20
	}
	if m.Category != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StructDefender) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StructDefender) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StructDefender) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CounterAttackSameAmbit != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.CounterAttackSameAmbit))
		i--
		dAtA[i] = 0x38
	}
	if m.CounterAttack != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.CounterAttack))
		i--
		dAtA[i] = 0x30
	}
	if m.OperatingAmbit != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.OperatingAmbit))
		i--
		dAtA[i] = 0x28
	}
	if len(m.LocationId) > 0 {
		i -= len(m.LocationId)
		copy(dAtA[i:], m.LocationId)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.LocationId)))
		i--
		dAtA[i] = 0x22
	}
	if m.LocationType != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.LocationType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DefendingStructId) > 0 {
		i -= len(m.DefendingStructId)
		copy(dAtA[i:], m.DefendingStructId)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.DefendingStructId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProtectedStructId) > 0 {
		i -= len(m.ProtectedStructId)
		copy(dAtA[i:], m.ProtectedStructId)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.ProtectedStructId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StructAttributeRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StructAttributeRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StructAttributeRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintStruct(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AttributeId) > 0 {
		i -= len(m.AttributeId)
		copy(dAtA[i:], m.AttributeId)
		i = encodeVarintStruct(dAtA, i, uint64(len(m.AttributeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStruct(dAtA []byte, offset int, v uint64) int {
	offset -= sovStruct(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Struct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovStruct(uint64(m.Index))
	}
	if m.Type != 0 {
		n += 1 + sovStruct(uint64(m.Type))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.LocationType != 0 {
		n += 1 + sovStruct(uint64(m.LocationType))
	}
	l = len(m.LocationId)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.OperatingAmbit != 0 {
		n += 1 + sovStruct(uint64(m.OperatingAmbit))
	}
	if m.Slot != 0 {
		n += 1 + sovStruct(uint64(m.Slot))
	}
	return n
}

func (m *StructType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStruct(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.Category != 0 {
		n += 1 + sovStruct(uint64(m.Category))
	}
	if m.BuildDifficulty != 0 {
		n += 1 + sovStruct(uint64(m.BuildDifficulty))
	}
	if m.BuildDraw != 0 {
		n += 1 + sovStruct(uint64(m.BuildDraw))
	}
	if m.MaxHealth != 0 {
		n += 1 + sovStruct(uint64(m.MaxHealth))
	}
	if m.PassiveDraw != 0 {
		n += 1 + sovStruct(uint64(m.PassiveDraw))
	}
	if m.PossibleAmbit != 0 {
		n += 1 + sovStruct(uint64(m.PossibleAmbit))
	}
	if m.Movable {
		n += 2
	}
	if m.SlotBound {
		n += 2
	}
	if m.PrimaryWeapon != 0 {
		n += 1 + sovStruct(uint64(m.PrimaryWeapon))
	}
	if m.PrimaryWeaponControl != 0 {
		n += 1 + sovStruct(uint64(m.PrimaryWeaponControl))
	}
	if m.PrimaryWeaponCharge != 0 {
		n += 1 + sovStruct(uint64(m.PrimaryWeaponCharge))
	}
	if m.PrimaryWeaponTargets != 0 {
		n += 1 + sovStruct(uint64(m.PrimaryWeaponTargets))
	}
	if m.PrimaryWeaponShots != 0 {
		n += 1 + sovStruct(uint64(m.PrimaryWeaponShots))
	}
	if m.PrimaryWeaponDamage != 0 {
		n += 2 + sovStruct(uint64(m.PrimaryWeaponDamage))
	}
	if m.PrimaryWeaponBlockable {
		n += 3
	}
	if m.PrimaryWeaponCounterable {
		n += 3
	}
	if m.PrimaryWeaponRecoilDamage != 0 {
		n += 2 + sovStruct(uint64(m.PrimaryWeaponRecoilDamage))
	}
	if m.PrimaryWeaponShotSuccessRateNumerator != 0 {
		n += 2 + sovStruct(uint64(m.PrimaryWeaponShotSuccessRateNumerator))
	}
	if m.PrimaryWeaponShotSuccessRateDenominator != 0 {
		n += 2 + sovStruct(uint64(m.PrimaryWeaponShotSuccessRateDenominator))
	}
	if m.SecondaryWeapon != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeapon))
	}
	if m.SecondaryWeaponControl != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponControl))
	}
	if m.SecondaryWeaponCharge != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponCharge))
	}
	if m.SecondaryWeaponTargets != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponTargets))
	}
	if m.SecondaryWeaponShots != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponShots))
	}
	if m.SecondaryWeaponDamage != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponDamage))
	}
	if m.SecondaryWeaponBlockable {
		n += 3
	}
	if m.SecondaryWeaponCounterable {
		n += 3
	}
	if m.SecondaryWeaponRecoilDamage != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponRecoilDamage))
	}
	if m.SecondaryWeaponShotSuccessRateNumerator != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponShotSuccessRateNumerator))
	}
	if m.SecondaryWeaponShotSuccessRateDenominator != 0 {
		n += 2 + sovStruct(uint64(m.SecondaryWeaponShotSuccessRateDenominator))
	}
	if m.PassiveWeaponry != 0 {
		n += 2 + sovStruct(uint64(m.PassiveWeaponry))
	}
	if m.UnitDefenses != 0 {
		n += 2 + sovStruct(uint64(m.UnitDefenses))
	}
	if m.OreReserveDefenses != 0 {
		n += 2 + sovStruct(uint64(m.OreReserveDefenses))
	}
	if m.PlanetaryDefenses != 0 {
		n += 2 + sovStruct(uint64(m.PlanetaryDefenses))
	}
	if m.PlanetaryMining != 0 {
		n += 2 + sovStruct(uint64(m.PlanetaryMining))
	}
	if m.PlanetaryRefinery != 0 {
		n += 2 + sovStruct(uint64(m.PlanetaryRefinery))
	}
	if m.PowerGeneration != 0 {
		n += 2 + sovStruct(uint64(m.PowerGeneration))
	}
	if m.ActivateCharge != 0 {
		n += 2 + sovStruct(uint64(m.ActivateCharge))
	}
	if m.BuildCharge != 0 {
		n += 2 + sovStruct(uint64(m.BuildCharge))
	}
	if m.DefendChangeCharge != 0 {
		n += 2 + sovStruct(uint64(m.DefendChangeCharge))
	}
	if m.MoveCharge != 0 {
		n += 2 + sovStruct(uint64(m.MoveCharge))
	}
	if m.OreMiningCharge != 0 {
		n += 2 + sovStruct(uint64(m.OreMiningCharge))
	}
	if m.OreRefiningCharge != 0 {
		n += 2 + sovStruct(uint64(m.OreRefiningCharge))
	}
	if m.StealthActivateCharge != 0 {
		n += 2 + sovStruct(uint64(m.StealthActivateCharge))
	}
	if m.AttackReduction != 0 {
		n += 2 + sovStruct(uint64(m.AttackReduction))
	}
	if m.AttackCounterable {
		n += 3
	}
	if m.StealthSystems {
		n += 3
	}
	if m.CounterAttack != 0 {
		n += 2 + sovStruct(uint64(m.CounterAttack))
	}
	if m.CounterAttackSameAmbit != 0 {
		n += 2 + sovStruct(uint64(m.CounterAttackSameAmbit))
	}
	if m.PostDestructionDamage != 0 {
		n += 2 + sovStruct(uint64(m.PostDestructionDamage))
	}
	if m.GeneratingRate != 0 {
		n += 2 + sovStruct(uint64(m.GeneratingRate))
	}
	if m.PlanetaryShieldContribution != 0 {
		n += 2 + sovStruct(uint64(m.PlanetaryShieldContribution))
	}
	if m.UnguidedDefensiveSuccessRateNumerator != 0 {
		n += 2 + sovStruct(uint64(m.UnguidedDefensiveSuccessRateNumerator))
	}
	if m.UnguidedDefensiveSuccessRateDenominator != 0 {
		n += 2 + sovStruct(uint64(m.UnguidedDefensiveSuccessRateDenominator))
	}
	if m.GuidedDefensiveSuccessRateNumerator != 0 {
		n += 2 + sovStruct(uint64(m.GuidedDefensiveSuccessRateNumerator))
	}
	if m.GuidedDefensiveSuccessRateDenominator != 0 {
		n += 2 + sovStruct(uint64(m.GuidedDefensiveSuccessRateDenominator))
	}
	return n
}

func (m *StructDefender) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtectedStructId)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.DefendingStructId)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.LocationType != 0 {
		n += 1 + sovStruct(uint64(m.LocationType))
	}
	l = len(m.LocationId)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.OperatingAmbit != 0 {
		n += 1 + sovStruct(uint64(m.OperatingAmbit))
	}
	if m.CounterAttack != 0 {
		n += 1 + sovStruct(uint64(m.CounterAttack))
	}
	if m.CounterAttackSameAmbit != 0 {
		n += 1 + sovStruct(uint64(m.CounterAttackSameAmbit))
	}
	return n
}

func (m *StructAttributeRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttributeId)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovStruct(uint64(m.Value))
	}
	return n
}

func sovStruct(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStruct(x uint64) (n int) {
	return sovStruct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Struct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Struct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Struct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationType", wireType)
			}
			m.LocationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationType |= ObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingAmbit", wireType)
			}
			m.OperatingAmbit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatingAmbit |= Ambit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StructType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StructType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StructType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= ObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDifficulty", wireType)
			}
			m.BuildDifficulty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildDifficulty |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDraw", wireType)
			}
			m.BuildDraw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildDraw |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHealth", wireType)
			}
			m.MaxHealth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHealth |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveDraw", wireType)
			}
			m.PassiveDraw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassiveDraw |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PossibleAmbit", wireType)
			}
			m.PossibleAmbit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PossibleAmbit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Movable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Movable = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotBound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SlotBound = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeapon", wireType)
			}
			m.PrimaryWeapon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeapon |= TechActiveWeaponry(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponControl", wireType)
			}
			m.PrimaryWeaponControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponControl |= TechWeaponControl(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponCharge", wireType)
			}
			m.PrimaryWeaponCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponTargets", wireType)
			}
			m.PrimaryWeaponTargets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponTargets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponShots", wireType)
			}
			m.PrimaryWeaponShots = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponShots |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponDamage", wireType)
			}
			m.PrimaryWeaponDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponDamage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponBlockable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrimaryWeaponBlockable = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponCounterable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrimaryWeaponCounterable = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponRecoilDamage", wireType)
			}
			m.PrimaryWeaponRecoilDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponRecoilDamage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponShotSuccessRateNumerator", wireType)
			}
			m.PrimaryWeaponShotSuccessRateNumerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponShotSuccessRateNumerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryWeaponShotSuccessRateDenominator", wireType)
			}
			m.PrimaryWeaponShotSuccessRateDenominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryWeaponShotSuccessRateDenominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeapon", wireType)
			}
			m.SecondaryWeapon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeapon |= TechActiveWeaponry(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponControl", wireType)
			}
			m.SecondaryWeaponControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponControl |= TechWeaponControl(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponCharge", wireType)
			}
			m.SecondaryWeaponCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponTargets", wireType)
			}
			m.SecondaryWeaponTargets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponTargets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponShots", wireType)
			}
			m.SecondaryWeaponShots = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponShots |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponDamage", wireType)
			}
			m.SecondaryWeaponDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponDamage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponBlockable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondaryWeaponBlockable = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponCounterable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondaryWeaponCounterable = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponRecoilDamage", wireType)
			}
			m.SecondaryWeaponRecoilDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponRecoilDamage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponShotSuccessRateNumerator", wireType)
			}
			m.SecondaryWeaponShotSuccessRateNumerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponShotSuccessRateNumerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryWeaponShotSuccessRateDenominator", wireType)
			}
			m.SecondaryWeaponShotSuccessRateDenominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryWeaponShotSuccessRateDenominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveWeaponry", wireType)
			}
			m.PassiveWeaponry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassiveWeaponry |= TechPassiveWeaponry(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitDefenses", wireType)
			}
			m.UnitDefenses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitDefenses |= TechUnitDefenses(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OreReserveDefenses", wireType)
			}
			m.OreReserveDefenses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OreReserveDefenses |= TechOreReserveDefenses(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanetaryDefenses", wireType)
			}
			m.PlanetaryDefenses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanetaryDefenses |= TechPlanetaryDefenses(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanetaryMining", wireType)
			}
			m.PlanetaryMining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanetaryMining |= TechPlanetaryMining(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanetaryRefinery", wireType)
			}
			m.PlanetaryRefinery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanetaryRefinery |= TechPlanetaryRefineries(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerGeneration", wireType)
			}
			m.PowerGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerGeneration |= TechPowerGeneration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivateCharge", wireType)
			}
			m.ActivateCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivateCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildCharge", wireType)
			}
			m.BuildCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefendChangeCharge", wireType)
			}
			m.DefendChangeCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefendChangeCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveCharge", wireType)
			}
			m.MoveCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OreMiningCharge", wireType)
			}
			m.OreMiningCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OreMiningCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OreRefiningCharge", wireType)
			}
			m.OreRefiningCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OreRefiningCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StealthActivateCharge", wireType)
			}
			m.StealthActivateCharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StealthActivateCharge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackReduction", wireType)
			}
			m.AttackReduction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackReduction |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackCounterable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackCounterable = bool(v != 0)
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StealthSystems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StealthSystems = bool(v != 0)
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterAttack", wireType)
			}
			m.CounterAttack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CounterAttack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterAttackSameAmbit", wireType)
			}
			m.CounterAttackSameAmbit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CounterAttackSameAmbit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostDestructionDamage", wireType)
			}
			m.PostDestructionDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostDestructionDamage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratingRate", wireType)
			}
			m.GeneratingRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneratingRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanetaryShieldContribution", wireType)
			}
			m.PlanetaryShieldContribution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanetaryShieldContribution |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnguidedDefensiveSuccessRateNumerator", wireType)
			}
			m.UnguidedDefensiveSuccessRateNumerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnguidedDefensiveSuccessRateNumerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnguidedDefensiveSuccessRateDenominator", wireType)
			}
			m.UnguidedDefensiveSuccessRateDenominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnguidedDefensiveSuccessRateDenominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuidedDefensiveSuccessRateNumerator", wireType)
			}
			m.GuidedDefensiveSuccessRateNumerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuidedDefensiveSuccessRateNumerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuidedDefensiveSuccessRateDenominator", wireType)
			}
			m.GuidedDefensiveSuccessRateDenominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuidedDefensiveSuccessRateDenominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StructDefender) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StructDefender: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StructDefender: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedStructId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtectedStructId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefendingStructId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefendingStructId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationType", wireType)
			}
			m.LocationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationType |= ObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingAmbit", wireType)
			}
			m.OperatingAmbit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatingAmbit |= Ambit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterAttack", wireType)
			}
			m.CounterAttack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CounterAttack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterAttackSameAmbit", wireType)
			}
			m.CounterAttackSameAmbit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CounterAttackSameAmbit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StructAttributeRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StructAttributeRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StructAttributeRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStruct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStruct
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStruct
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStruct
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStruct        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStruct          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStruct = fmt.Errorf("proto: unexpected end of group")
)
